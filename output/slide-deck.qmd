---
title:       "Version control for reproducible research and collaboration"
subtitle:    "An overview of git + Github in scientific workflows"
date:        2023-06-09
date-format: short
author:      "[Daniel Morillo, Ph.D.](https://orcid.org/0000-0003-3021-3878)"
format:
  revealjs:
    slide-number:            true
    fig-align:               center
    fig-cap-location:        bottom
    incremental:             true
    link-external-newwindow: true
    preview-links:           false
    preload-iframes:         true
    self-contained:          true
    theme:                   simple
    view-distance:                3
---

# Intro: Why version control?

```{=html}
<!--  ## Introduction

<br>

[Daniel Morillo, Ph.D.](https://orcid.org/0000-0003-3021-3878)

Postdoctoral Researcher \@ [CiberSam](https://www.cibersam.es/en) -->
```
## Problem

![](../www/phd_versions.png){fig-align="center" height="40%"}

::: notes
What I'm going to talk about in this seminar is the problem illustrated in this
comic strip. Not the frustration of having to go through several rounds of
reviews, of course, but how to manage and keep track of all the changes and
versions his thesis has gone all throughout.

Have you ever encountered yourself with such a problem?

Some of the most common problems one finds when trying to manage the different
versions of their work are...
:::

## Problem

> -   What is the most updated version?

-   When did this code / draft / protocol / etc. change, and why?

-   Does this version have the last changes?

-   Did I take into account the reviews of all co-authors?

</br>

-   other... ?

::: notes
For example, you may be asked by a colleague, reviewer, or an interested reader
about your analysis... what was the code you wrote and used, exactly? Also, what
was the state of your environment (R packages, other dependencies) at the time
you generated your results?

(NEXT)

You may also have changed your code at a certain point. Even if you are sure
about which version is used for what, do you know exactly why there are
different versions at all?

Are they all useful, or some of them are just backup copies?

How did you come up with this version, and why? Did a previous one not work, or
was it wrong for some reason?

(NEXT)

After several rounds of reviews, are you sure you are working on the latest
version?

(NEXT)

And, have you integrated the changes and suggestions of all your co-authors?

(NEXT)

What other problems have you found along in your research daily work?

(LET TIME FOR DEBATE)
:::

# Solutions

::: notes
So, there are several ways of sorting this out.
:::

## Manual versioning

::: columns
::: column
![](../www/swith_to_vc.jpg){fig-align="center" height="100%"}
:::

::: column
</br>

-   Shared files (cloud service / network units)

</br>

-   File naming conventions
:::
:::

::: notes
The most obvious one is manual versioning, which most of us are probably used
to.

(NEXT)

To allow sharing files, we can store them in cloud services or network units...

(NEXT)

and implement some file naming conventions to keep track of the different
versions. Unlike this guy (picture), we can e.g. preffix the naem with a date,
suffix with a version number, or with the initials of the last reviewer...

Do you use any service or system to share files, and/or file naming conventions?

(LET TIME FOR DEBATE)
:::

## Manual versioning

</br>

> -   Errors

-   Work lost

-   Duplicated effort

</br>

-   other problems... ?

::: notes
We probably have suffered from some problems with manual versioning, like
errors. The most obvious one, accidentally deleting a file and having to start
again at a previous point.

(NEXT)

But not only. It may happen that we just don't find a previous version, so we
may need to redo some of the work.

(NEXT)

Or worse than that: We do a lot of work, e.g. writing or updating a script, only
to find out that a colleague had done the same (or something similar) before.

(NEXT)

What other problemas have you found when using a manual versioning system?

(LET TIME FOR DEBATE)
:::

## Version control

![](../www/flowchart.png){fig-align="center" height="100%"}

::: notes
Well, for these reasons, version control systems were created. Now, going back
to my initial question, the point would be:
:::

# Why version control?

::: notes
"Should I use it?"

Let's see the feature of version control systems, and why they are useful.
:::

## Collaboration

![](../www/git_server.png){fig-align="center" height="100%"}

::: notes
First of all: collaboration, it's most useful feature. Nowadays every research
project is collaborative, in one way or another. Being able to collaborate
seamlessly is something every system should allow.

By using a centralized version control system, everyone in a project can share,
contribute, and reuse the work of one another.
:::

## History of changes

::: columns
::: column
![](../www/Nobel-Prize-Timeline.png){fig-align="center" height="100%"}
:::

::: column
-   What

-   When

-   Why

-   Who
:::
:::

::: notes
This is an example of a timeline, with specific events at a certain point in
time. This is the analogy you need to keep in mind to understand what a version
control system is.

In essence, it is a history of the changes in a project (or a "repository", in
the version control jargon).

With this timeline, we have the information about what has changed,...

(NEXT)

but also when (for example, seeing the timeline we may know what results are
affected if an analysis script has changed, and whether they need to be
updated),...

(NEXT)

why (this can help provide a lot of knowledge),

(NEXT)

and by whom (which is important because we can gather more information about why
a change was made, if necessary).

Also, attribution is always granted. This can provide, in my opinion, a serious
breakthrough when dealing with ghost authorship.
:::

## History of changes

... can be a lifeline

![](../www/vc-xkcd.jpg){fig-align="center" height="100%"}

::: notes
Also, this history is always available (no matter what). So it is a backup
system that protects us against dramatic errors that make us lose the work done.
:::

## History of changes

Don't be afraid of "moving forward"

![](../www/documentation.png){fig-align="center" height="100%"}

::: notes
What does this means? We don't need to be held back to make changes by fear of
deleting something important.

Also, we don't need to be documenting our "previous versions" in obscure ways,
as this poor guy is doing.

However, if we are not sure about our changes, we can still make progress
without fear thanks to another important feature...
:::

## Parallel histories

![](../www/back-to-the-future-ii.jpg){fig-align="center" height="100%"}

::: notes
Do you recognize this film?

(PAUSE AND EXPLAIN)

This is exactly what "branching" does: Creating a "parallel history".
:::

## Parallel histories

Branching:

![](../git-branch.PNG){fig-align="center" height="100%"}

-   Review

-   Experiment

-   Integrate / dismiss

::: notes
The ability to "suggest changes" in parallel...

(NEXT)

or do "experiments", without affecting the main outcome of our project, is a
very prominent feature of VC.

This way, we can "change things" without the fear of conflicting with what is
already done.

That's how far the "Back to the future" metaphor goes though.

(NEXT)

Because then, if we are satisfied with the new changes, and maybe gather enough
consensus, we can merge these new changes with the main history, so the changes
go to the final output.
:::

## Parallel histories

Merging a branch:

![](../www/merge-branch.png){fig-align="center" height="100%"}

::: notes
Or of course, we can just abandon that branch, if we thing we have come to a
dead end, or we are not satisfied with the result.

However, one thing is very important, whether we merge our parallel to the main
history or not: Nothing is ever lost (unless we want it to, of course). And this
is very important in research, right?
:::

## Reproducibility

::: columns
::: column
![](../www/the_difference.png){fig-align="center" height="100%"}
:::

::: column
> -   ... of results

-   Replicability

-   Transparency
:::
:::

::: notes
Because our results will of course be reproducible: We can also our code (or our
whole project, for that matter) and see if we arrive at the same results we have
reported.

(NEXT)

Moreover, replicability is easy: We "only" need the same code and a new dataset.

But there is something beyond that...

(NEXT)

which I like to call transparency.
:::

## Reproducibility

> When most people think about design, they often think of it as just the final
> output: the screens. What they don't see, or aren't aware of, is all of the
> work that goes into identifying and articulating the problem, gathering data,
> planning, consensus-building, decision-making, and conversations with
> stakeholders that ultimately lead to that final output. All of these things
> make up the design process.\

--Josh Brewer

::: notes
Have a look at this quote.

It is taken from a web design blog; it is not about scientific research, but I
can't stress enough how true it is when we apply it to scientific research.

Let me read it, "translating" it to "scientific jargon".

This is, in my opinion, the most important feature of version control:
Reproducibility (or better, transparency) of workflows, not only results.
:::

# Why not version control...?

::: notes
So we see that version control solves all and every problem we may have with
managing our research projects, and it also allows us to have a completely
reproducible and transparent workflow.

Why is not everybody in academia using it?
:::

# 

![](../www/bryan.jpg){fig-align="center" height="100%"}

::: notes
The main reason is this: Version control was built by SW engineers, for SW
engineers... and we all know some IT people, we know they are "special"
somehow... :)

They open ugly black terminal windows, run a lot of alien, esoteric commands,
and then they make memes like this, mocking the rest of us mortals for not
understanding what they do!

Of course one does not need to learn commands, because git (and all version
control systems, for that matter)...
:::

# 

![](../www/git-gui.jpg){fig-align="center" height="100%"}

::: notes
have graphical user interfaces to make our life simpler. Later on we will see
how git integrates with Rstudio, which has a very simple interface for git, but
there are other ones, that allow us to do many more things easily, without
having to learn commands.

Even though...
:::

## Learning curve

![](../www/understand-git.jpg){fig-align="center" height="100%"}

::: notes
learning to use these version control systems is difficult. And it takes time.

By my estimates, I would say that the investment starts paying off around the
third article done in version control.
:::

## File types

::: notes
Version control works best with "text files". And most of us are used to work
with binary files, most of the time.
:::

# How to...
